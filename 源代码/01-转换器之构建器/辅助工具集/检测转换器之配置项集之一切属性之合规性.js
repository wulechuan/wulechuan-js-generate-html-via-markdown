const 彩色粉笔工具 = require('chalk')

const { 本NPM包之NPM名称 } = require('../../面向研发阶段之配置')
const 完备的默认配置项集 = require('../../完备的默认配置项集')

const 所有作用于Markdown原始内容之内建替换规则之字典 = require('../../内建现成的-markdown-内容替换规则集字典')
const 所有作用于HTML内容之内建替换规则之字典 = require('../../内建现成的-html-内容替换规则集字典')



const {
    构建一条错误消息字符串,
    构建一条错误消息字符串以阐明数据之期望之类型,
} = require('../../99-辅助工具集/构建错误消息字符串')



module.exports = function 检测转换器之配置项集之一切属性之合规性 (转换器之配置项集) {
    const 本代码范畴之描述 = '检测转换器之配置项集之一切属性之合规性()'

    function 构建一条本代码范畴内的错误消息字符串 (消息正文逐行内容) {
        return 构建一条错误消息字符串(消息正文逐行内容, 本代码范畴之描述, 本NPM包之NPM名称)
    }

    function 构建一条错误消息字符串以阐明数据本应为该类型 (合规的类型列表, 得到的实际值, 该值之称谓或访问路径) {
        return 构建一条错误消息字符串以阐明数据之期望之类型(合规的类型列表, 得到的实际值, 该值之称谓或访问路径, 本代码范畴之描述, 本NPM包之NPM名称)
    }





    if (!转换器之配置项集) { return true }



    if (Array.isArray(转换器之配置项集)) {
        const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
            '非数组之对象',
            转换器之配置项集,
            '转换器之配置项集本身'
        )

        console.log(错误消息)

        return false
    }

    const 属性访问路径之根之名称 = '<给出的转换器之配置项集>'
    let 错误计数 = 0

    检测单一对象(完备的默认配置项集, 转换器之配置项集, [ 属性访问路径之根之名称 ])
    console.log('\n', 彩色粉笔工具.red('累计错误数：'), 错误计数, '\n')

    return 错误计数 === 0



    function 检测单一对象 (标准配置项集之子集, 给出之转换器配置项之子集, 父层级之访问路径) {
        Object.keys(给出之转换器配置项之子集).forEach(键 => {
            const 标准值 = 标准配置项集之子集[键]
            const 值 = 给出之转换器配置项之子集[键]

            let 键之打印名称 = `.${键}`
            if (!/^[$_a-zA-z\u4e00-\u9fa5][$_\da-zA-Z\u4e00-\u9fa5]*/.test(键)) {
                键之打印名称 = `['${键}']`
            }

            const 该键之完整访问路径 = 父层级之访问路径.concat(键之打印名称)

            if (!(键 in 标准配置项集之子集)) {
                const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                    '<不应存在>',
                    值,
                    该键之完整访问路径
                )

                console.log(错误消息)

                if (值 || 值 === 0 || 值 === '' || (typeof 值 === 'number' && isNaN(值))) {
                    错误计数++
                }
            } else {
                if (typeof 值 === 'object' && typeof 标准值 === 'object') {
                    if (Array.isArray(值) && !Array.isArray(标准值)) {
                        const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                            '非数组之对象',
                            值,
                            该键之完整访问路径
                        )

                        console.log(错误消息)

                        错误计数++
                    } else if (!Array.isArray(值) && Array.isArray(标准值)) {
                        const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                            '数组',
                            值,
                            该键之完整访问路径
                        )

                        console.log(错误消息)

                        错误计数++
                    }
                } else if (值 || 值 === 0 || 值 === '') {
                    if (typeof 值 !== typeof 标准值) {
                        const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                            typeof 标准值,
                            值,
                            该键之完整访问路径
                        )

                        console.log(错误消息)

                        错误计数++
                    }
                } else if (typeof 值 === 'number' && isNaN(值)) {
                    const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                        '有意义之数字',
                        值,
                        该键之完整访问路径
                    )

                    console.log(错误消息)

                    错误计数++
                }
            }

            if (值) {
                if (Array.isArray(值)) {
                    const 合规的父层级访问路径1 = [
                        `${属性访问路径之根之名称}.将Markdown转换为HTML之前之预备阶段.须对原始Markdown内容字符串依次按下诸内容替换规则做修订`,
                        `${属性访问路径之根之名称}.对HTML做进一步处理之阶段.须对产出之HTML内容字符串依次遵照下列诸内容替换规则做修订`,
                    ]
                    const 合规的父层级访问路径2 = 合规的父层级访问路径1

                    const 父层级之访问路径字符串 = 父层级之访问路径.join('')

                    if (键 === '1 内建现成的替换规则之名称之序列') {
                        if (父层级之访问路径字符串 === 合规的父层级访问路径1[0]) {
                            const 合规的键名列表 = Object.keys(所有作用于Markdown原始内容之内建替换规则之字典)

                            值.forEach((值内项, 列表项之编号) => {
                                const 该值内项之完整访问路径 = 该键之完整访问路径.concat(`[${列表项之编号}]`)

                                if (typeof 值内项 !== 'string') {
                                    if (typeof 值内项 === 'undefined') {
                                        return
                                    }

                                    if (值内项 === null) {
                                        return
                                    }

                                    const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                        '字符串',
                                        值内项,
                                        该值内项之完整访问路径
                                    )

                                    console.log(错误消息)

                                    错误计数++
                                } else if (!合规的键名列表.includes(值内项)) {
                                    const 错误消息 = 构建一条本代码范畴内的错误消息字符串([
                                        彩色粉笔工具.red('“'),
                                        彩色粉笔工具.white(该值内项之完整访问路径.join('')), // TODO
                                        彩色粉笔工具.red('”之取值必须为以下之一：'),
                                        ...合规的键名列表.map(条目 => `    "${彩色粉笔工具.green(合规的键名列表)}"`),
                                        彩色粉笔工具.red(`而不应为“${彩色粉笔工具.yellow(值内项)}”。`),
                                    ])

                                    console.log(错误消息)

                                    错误计数++
                                }
                            })
                        } else if (父层级之访问路径字符串 === 合规的父层级访问路径1[1]) {
                            const 合规的键名列表 = Object.keys(所有作用于HTML内容之内建替换规则之字典)

                            值.forEach((值内项, 列表项之编号) => {
                                const 该值内项之完整访问路径 = 该键之完整访问路径.concat(`[${列表项之编号}]`)

                                if (typeof 值内项 !== 'string') {
                                    if (typeof 值内项 === 'undefined') {
                                        return
                                    }

                                    if (值内项 === null) {
                                        return
                                    }

                                    const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                        '字符串',
                                        值内项,
                                        该值内项之完整访问路径
                                    )

                                    console.log(错误消息)

                                    错误计数++
                                } else if (!合规的键名列表.includes(值内项)) {
                                    const 错误消息 = 构建一条本代码范畴内的错误消息字符串([
                                        彩色粉笔工具.red('“'),
                                        彩色粉笔工具.white(该值内项之完整访问路径.join('')), // TODO
                                        彩色粉笔工具.red('”之取值必须为以下之一：'),
                                        ...合规的键名列表.map(条目 => `    "${彩色粉笔工具.green(合规的键名列表)}"`),
                                        彩色粉笔工具.red(`而不应为“${彩色粉笔工具.yellow(值内项)}”。`),
                                    ])

                                    console.log(错误消息)

                                    错误计数++
                                }
                            })
                        } else {
                            // 其实不可能走到这个代码块。
                            const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                '<不应存在>',
                                值,
                                父层级之访问路径.concat(`['${键}']`)
                            )

                            console.log(错误消息)

                            错误计数++
                        }
                    } else if (键 === '2 额外的替换规则之定义之序列') {
                        if (!合规的父层级访问路径2.includes(父层级之访问路径字符串)) {
                            // 其实不可能走到这个代码块。
                            const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                '<不应存在>',
                                值,
                                父层级之访问路径.concat(`['${键}']`)
                            )

                            console.log(错误消息)

                            错误计数++
                        } else {
                            值.forEach((值内项, 列表项之编号) => {
                                const 该值内项之完整访问路径 = 该键之完整访问路径.concat(`[${列表项之编号}]`)

                                if (!!值内项 && typeof 值内项 === 'object') {
                                    const 合规之键之列表 = [ '凡', '替换为' ]

                                    Object.keys(值内项).forEach(值内项之键 => {
                                        if (!合规之键之列表.includes(值内项之键)) {
                                            const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                                '<不应存在>',
                                                值内项[值内项之键],
                                                该值内项之完整访问路径.concat(`.${值内项之键}`)
                                            )

                                            console.log(错误消息)

                                            错误计数++
                                        }
                                    })

                                    const 内值1 = 值内项.凡
                                    if (!(typeof 内值1 === 'string' || 内值1 instanceof RegExp)) {
                                        const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                            [ '字符串', '正则表达式' ],
                                            内值1,
                                            该值内项之完整访问路径.concat('.凡')
                                        )

                                        console.log(错误消息)

                                        错误计数++
                                    }

                                    const 内值2 = 值内项.替换为
                                    if (typeof 内值2 !== 'string') {
                                        const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                            '字符串',
                                            内值2,
                                            该值内项之完整访问路径.concat('.替换为')
                                        )

                                        console.log(错误消息)

                                        错误计数++
                                    }
                                } else {
                                    if (typeof 值内项 === 'undefined') {
                                        return
                                    }

                                    if (值内项 === null) {
                                        return
                                    }

                                    const 错误消息 = 构建一条错误消息字符串以阐明数据本应为该类型(
                                        '非数组之对象',
                                        值内项,
                                        该值内项之完整访问路径
                                    )

                                    console.log(错误消息)

                                    错误计数++
                                }
                            })
                        }
                    } else if (Array.isArray(标准值)) {
                        // 暂不处理。
                    }
                } else if (typeof 标准值 === 'object' && typeof 值 === 'object') {
                    检测单一对象(标准值, 值, 该键之完整访问路径)
                }
            }
        })
    }
}
